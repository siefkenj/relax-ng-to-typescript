import { visit } from "unist-util-visit";
import { toXml } from "xast-util-to-xml";
import { expected, isElement } from "../../xast-utils";
import {
    ElementTypeDescriptor,
    extractElementType,
} from "../extract/element-type";
import {
    NGSimpDefine,
    NGSimpGrammar,
    NGSimpRef,
} from "../simplification/simplified-types";
import { normalizeTypeName } from "./normalize-type-name";
import { NGElement, NGMethod } from "../types";

// Basic XML element names
const XML_ELEMENT = "XMLElement";
const XML_TEXT = "XMLText";
const XML_ELEMENT_WITH_NO_ATTRIBUTES = `Omit<${XML_ELEMENT}, "attributes">`;

const TYPES_PREAMBLE = `
/**
 * This file was AUTOGENERATED from a RELAX-NG grammar.
 */

import {Element as XMLElement, Text as XMLText} from "xast"\n\n`;

/**
 * Put quote marks around an XML attribute name if TypeScript would need quotes.
 */
function quoteAttributeIfNeeded(attr: string): string {
    if (attr.match(/[^a-zA-Z0-9_]/) || attr.charAt(0).match(/[0-9]/)) {
        return JSON.stringify(attr);
    }
    return attr;
}

/**
 * Outputs TypeScript code for a type representing the element described by `desc`. If
 * `refName` is supplied, it will be used as the type name. Otherwise the element name
 * will be used.
 */
export function makeElementType(desc: ElementTypeDescriptor, refName?: string) {
    const hasAttributes = Object.keys(desc.attributes).length > 0;
    const name = refName ? refName : normalizeTypeName(desc.name, "Element");

    const ret: string[] = [];

    if (hasAttributes) {
        ret.push(`interface ${name} extends ${XML_ELEMENT} {`);
    } else {
        ret.push(
            `interface ${name} extends ${XML_ELEMENT_WITH_NO_ATTRIBUTES} {`
        );
    }
    ret.push(`  name: ${JSON.stringify(desc.name)};`);
    if (hasAttributes) {
        ret.push(`  attributes: {`);
        ret.push(
            ...Object.entries(desc.attributes).map(
                ([attr, attrDesc]) =>
                    `    ${quoteAttributeIfNeeded(attr)}${
                        attrDesc.optional ? "?" : ""
                    }: ${attrDesc.type.join(" | ")};`
            )
        );
        ret.push("  };");
    }

    const children = desc.children.map((ref) => normalizeTypeName(ref.ref));
    if (desc.textChildrenAllowed) {
        children.push(XML_TEXT);
    }
    children.sort();

    if (children.length === 0) {
        ret.push("  children: never[];");
    } else {
        const typeStr =
            children.length === 1
                ? `${children[0]}[]`
                : `(${children.join(" | ")})[]`;
        ret.push(`  children: ${typeStr};`);
    }

    ret.push("}");

    const typeStr = ret.join("\n");
    return { typeStr, dependsOn: children };
}

export type JSONGrammar = {
    startType: string;
    refs: Record<string, JSONGrammarItem>;
};
export type JSONGrammarItem =
    | { type: "text" }
    | { type: "unknown" }
    | ReturnType<typeof extractElementType>;

/**
 * Output all types specified by the grammar in both TypeScript
 * form and JSON form.
 */
export function makeTypesForGrammar(grammar: NGSimpGrammar): {
    typescriptStr: string;
    grammar: JSONGrammar;
} {
    const start = grammar.children[0];
    const allDefs = grammar.children.slice(1) as NGSimpDefine[];
    let startRef = start.children[0];
    //console.log(start.children);
    try {
        expected(startRef, "ref");
    } catch {
        startRef = findElementRefInChoices(startRef as any, "ElementPretext");
        expected(startRef, "ref");
    }

    const allDefsMap: Record<string, NGSimpDefine> = Object.fromEntries(
        allDefs.map((def) => [def.attributes.name, def])
    );

    // `XMLText` is a special node that we create separately
    const exportedRefs: Record<string, JSONGrammarItem> = {
        XMLText: { type: "text" },
    };

    const interfaces: string[] = [
        `type StartElement = ${startRef.attributes.name};`,
    ];
    const queue: string[] = [startRef.attributes.name];
    // Recursively export all the types that are needed
    while (queue.length > 0) {
        const refName = queue.pop() || "";
        if (!refName || exportedRefs[refName]) {
            continue;
        }
        const ref = allDefsMap[refName];
        if (!ref) {
            // We encountered a type that doesn't have a definition.
            interfaces.push(generateTypeForMissingRef(refName));
            exportedRefs[refName] = { type: "unknown" };
            continue;
        }
        //if (refName.includes("Author")) {
        //    console.log("doing", refName);
        //}
        const elm = ref.children[0];
        const typeDesc = extractElementType(elm);
        const { typeStr, dependsOn } = makeElementType(typeDesc, refName);
        interfaces.push(typeStr);
        queue.push(...dependsOn);
        exportedRefs[refName] = typeDesc;

        //if (refName.includes("Author")) {
        //    console.log(typeStr);
        //}
    }

    return {
        typescriptStr:
            TYPES_PREAMBLE +
            "\n\n" +
            interfaces.map((i) => `export ${i}`).join("\n\n"),
        grammar: { startType: startRef.attributes.name, refs: exportedRefs },
    };
}

/**
 * Generate a type for a type named `typeName` that doesn't have a corresponding
 * `<define name="${typeName}">` tag in the grammar.
 */
function generateTypeForMissingRef(typeName: string): string {
    return `type ${typeName} = unknown;`;
}

/**
 * Drill down a `<choice>...</choice>` blocks and find the first ref
 * whose initial pattern matches the given `namePrefix`.
 */
function findElementRefInChoices(elm: NGMethod, namePrefix: string): NGSimpRef {
    const allFlatRefs: NGSimpRef[] = [];
    visit(elm as any, "element", (el) => {
        if (el.name === "ref") allFlatRefs.push(el);
    });

    const ret = allFlatRefs.find((ref) =>
        ref.attributes.name.startsWith(namePrefix)
    );

    if (ret) {
        return ret;
    }
    throw new Error(`Could not find ref with prefix ${namePrefix}`);
}
